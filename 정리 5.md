1) mypy daemon (dmypy)

왜 빠른가: 백그라운드 프로세스가 타입 정보 캐시를 유지해서, 파일 일부만 바뀌어도 전체 재분석을 안 함.

자주 쓰는 명령

dmypy start -- --strict      # 데몬 시작(+ 추가 옵션은 -- 뒤에)
dmypy recheck                # 변경분만 재검사 (매우 빠름)
dmypy stop                   # 데몬 종료


대안: CI처럼 데몬 못 쓰는 환경에선 mypy --incremental 사용.

2) INSERT/UPDATE 후 “바로 값 받기” (RETURNING 없는 MySQL)

상황: PostgreSQL처럼 INSERT ... RETURNING *가 안 되므로(일반적으로 MySQL은 RETURNING 미지원),
방금 만든/수정한 행을 곧바로 얻으려면 추가 쿼리가 필요.

패턴 A: ORM 사용 (권장)

Tortoise/SQLAlchemy 등 ORM은 create()가 객체를 반환하고, PK도 채워 줌.

meeting = await MeetingModel.create(url_code="abc123")
# meeting.id / meeting.url_code 바로 사용 가능


패턴 B: Raw SQL 사용

INSERT 실행

LAST_INSERT_ID()(또는 드라이버가 주는 lastrowid)로 PK 획득

SELECT로 필요한 컬럼 조회

INSERT INTO meeting(url_code) VALUES ('abc123');
SELECT LAST_INSERT_ID();         -- PK 얻기
SELECT * FROM meeting WHERE id = LAST_INSERT_ID();


UPDATE도 동일: 변경 결과를 즉시 받고 싶다면 다시 SELECT 해서 읽어와야 한다.

주의: 트랜잭션 경계 밖에서 LAST_INSERT_ID()를 섞어 쓰면 다른 세션 값과 꼬일 수 있으니, 같은 커넥션/세션 안에서 처리.

3) 바다코끼리 연산자 := (Walrus Operator)

정의: “할당하면서 그 값을 반환”하는 연산자.

실전 패턴

# 조건에서 값 한 번만 계산/검증하고 재사용
if payload := await request.json():
    do_something(payload)


검증 로직과 궁합: Falsy 체크로 분기하기 쉬움.

if (title := body.get("title")) and len(title) <= 100:
    ...
else:
    raise HTTPException(422, "invalid title")


리턴 누락 주의: 분기마다 return이 없으면 mypy가 “경로에 따라 None 반환”을 잡아냄.

해결: 모든 분기에 명시적 return 또는 raise 두기.

def normalize(x: str) -> str:
    if x:
        return x.strip()
    raise ValueError("empty")   # None 경로 제거


언제 쓰지 말기

복잡한 조건에 남발하면 가독성↓ → 짧은 검증/캐싱 정도에만.

한 줄 요약

mypy는 dmypy로 빠르게 돌리고,

MySQL은 RETURNING이 없으니 INSERT/UPDATE 후 추가 SELECT(혹은 ORM의 반환 객체)로 값 확보,

Walrus는 짧은 검증·캐싱에만 쓰고, 분기마다 return/raise 확실히.
